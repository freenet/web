<div class="sync-visualization-wrapper">
  <style>
    .sync-visualization-wrapper {
      width: 100%;
      margin: 2rem auto;
      min-height: 300px;
    }
    .peer-container {
      position: relative;
      display: flex;
      justify-content: space-around;
      align-items: flex-start;
      gap: 4rem;
      margin: 2rem;
      min-height: 200px;
      padding: 1rem;
    }
    .peer {
      flex: 1;
      max-width: 150px;
      padding: 1rem;
      border: 2px solid #ccc;
      border-radius: 8px;
      background: #f9f9f9;
    }
    .peer-title {
      text-align: center;
      font-weight: bold;
      margin-bottom: 1rem;
    }
    .peer-icons {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: center;
      min-height: 50px;
      margin-bottom: 1rem;
    }
    .peer-icon {
      font-size: 2rem;
      color: #2c3e50;
    }
    .summary-display, .delta-display {
      position: absolute;
      background: #fff;
      padding: 1rem;
      width: 150px;
      font-family: monospace;
      opacity: 0;
      visibility: hidden;
      transition: all 0.5s ease-in-out;
      pointer-events: none;
      z-index: 1000;
      position: absolute;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      border-radius: 6px;
    }
    .summary-display {
      border: 2px solid #ff3860;
      border-radius: 4px;
      background: #fff0f4;
    }
    .delta-display {
      border: 2px solid #00d1b2;
      border-radius: 4px;
      background: #f0fffc;
    }
    .summary-display.visible, .delta-display.visible {
      opacity: 1 !important;
      visibility: visible !important;
      pointer-events: auto;
    }
    .summary-title {
      font-weight: bold;
      margin-bottom: 0.5rem;
      text-align: center;
    }
    .summary-list {
      margin: 0;
      padding: 0;
      list-style: none;
    }
    .summary-list li {
      padding: 2px 4px;
      margin: 2px 0;
      border-radius: 2px;
      transition: opacity 0.3s;
    }
    .summary-title {
      font-weight: bold;
      color: #3273dc;
      margin-bottom: 0.5rem;
    }
    .summary-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .sync-controls {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin: 1rem 0;
    }
    button:disabled {
      cursor: default;
    }
    @media (max-width: 768px) {
      .peer-container {
        flex-direction: column;
        align-items: center;
      }
      .peer {
        width: 100%;
      }
    }
  </style>

  <div class="visualization-controls" style="text-align: center; margin: 1rem;">
    <div class="buttons has-addons is-centered" style="margin-bottom: 0.5rem;">
      <button id="syncNextBtn" class="button is-medium is-primary">
        <span class="icon">
          <i class="fas fa-step-forward"></i>
        </span>
        <span>Next</span>
      </button>
      <button id="resetSyncBtn" class="button is-medium">
        <span class="icon">
          <i class="fas fa-undo"></i>
        </span>
        <span>Reset</span>
      </button>
    </div>
    <p id="stepCaption" class="has-text-centered" style="margin: 1rem; font-style: italic;">
      Click "Next" to begin the synchronization process.
    </p>
  </div>

  <div class="peer-container">
    <div class="peer" id="peer1">
      <div class="peer-title">Peer 1</div>
      <div class="peer-icons"></div>
    </div>
    <div class="peer" id="peer2">
      <div class="peer-title">Peer 2</div>
      <div class="peer-icons"></div>
    </div>
  </div>

  <div id="summary1" class="summary-display">
    <div class="summary-title">Summary</div>
    <ul class="summary-list"></ul>
  </div>
  <div id="summary2" class="summary-display">
    <div class="summary-title">Summary</div>
    <ul class="summary-list"></ul>
  </div>
  <div id="delta1" class="delta-display">
    <div class="summary-title">Delta</div>
    <ul class="summary-list"></ul>
  </div>
  <div id="delta2" class="delta-display">
    <div class="summary-title">Delta</div>
    <ul class="summary-list"></ul>
  </div>

  <script>
    // Available FontAwesome icons for the visualization
    const availableIcons = [
      { name: 'dog', class: 'fas fa-dog' },
      { name: 'cat', class: 'fas fa-cat' },
      { name: 'fish', class: 'fas fa-fish' },
      { name: 'dove', class: 'fas fa-dove' },
      { name: 'dragon', class: 'fas fa-dragon' },
      { name: 'spider', class: 'fas fa-spider' },
      { name: 'horse', class: 'fas fa-horse' },
      { name: 'hippo', class: 'fas fa-hippo' }
    ];

    // State for each peer
    const peerState = {
      peer1: {
        icons: [],
        summary: '',
        delta: []
      },
      peer2: {
        icons: [],
        summary: '',
        delta: []
      }
    };

    // Initialize with random icons
    function initializePeers() {
      // Clear existing state
      peerState.peer1.icons = [];
      peerState.peer2.icons = [];
      peerState.peer1.summary = '';
      peerState.peer2.summary = '';
      peerState.peer1.delta = [];
      peerState.peer2.delta = [];

      // Shuffle available icons
      const shuffled = [...availableIcons].sort(() => Math.random() - 0.5);
      
      // Select one common icon that both peers will have
      const commonIcon = shuffled[0];
      
      // Assign 2-4 random icons to each peer, including the common icon
      const peer1Count = Math.floor(Math.random() * 2) + 2; // 2-3 additional icons
      const peer2Count = Math.floor(Math.random() * 2) + 2; // 2-3 additional icons
      
      // Assign unique icons to each peer, plus the common icon
      peerState.peer1.icons = [commonIcon, ...shuffled.slice(1, peer1Count + 1)];
      peerState.peer2.icons = [commonIcon, ...shuffled.slice(peer1Count + 1, peer1Count + peer2Count + 1)];

      // Update UI
      updatePeerUI('peer1');
      updatePeerUI('peer2');
      
      // Clear summary and delta boxes
      document.querySelectorAll('.summary-box').forEach(box => box.textContent = '');
      document.querySelectorAll('.delta-box').forEach(box => box.textContent = '');
    }

    // Update the UI for a peer
    function updatePeerUI(peerId) {
      const iconContainer = document.querySelector(`#${peerId} .peer-icons`);
      iconContainer.innerHTML = '';
      
      peerState[peerId].icons.forEach(icon => {
        const iconElement = document.createElement('i');
        iconElement.className = `peer-icon ${icon.class}`;
        iconContainer.appendChild(iconElement);
      });
    }

    let isAnimating = false;
    let currentStep = 0;
    let nextStepQueued = false;
    const ANIMATION_DELAY = 1000;


    async function runSyncAnimation() {
      switch(currentStep) {
        case 1: // Generate and show summaries
          await generateAndAnimateSummaries();
          break;
          
        case 2: // Exchange summaries
          await exchangeSummaries();
          break;
          
        case 3: // Generate deltas
          await generateDeltas();
          break;
          
        case 4: // Exchange deltas
          await exchangeDeltas();
          break;
          
        case 5: // Merge deltas
          await mergeDeltas();
          break;
          
        case 6: // Final state
          // Show completion message
          break;
      }
    }

    async function generateAndAnimateSummaries() {
      return new Promise((resolve) => {
        const summary1 = document.getElementById('summary1');
        const summary2 = document.getElementById('summary2');
        
        // Clear existing content
        summary1.querySelector('.summary-list').innerHTML = '';
        summary2.querySelector('.summary-list').innerHTML = '';
        
        // Get peer elements and their positions
        const peer1 = document.getElementById('peer1');
        const peer2 = document.getElementById('peer2');
        const peer1Rect = peer1.getBoundingClientRect();
        const peer2Rect = peer2.getBoundingClientRect();
        
        // Position summaries beside their respective peers
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        
        // First position the summaries before making them visible
        summary1.style.transition = 'none';
        summary2.style.transition = 'none';
        
        // Position summary1 to the right of peer1
        summary1.style.left = `${peer1Rect.right + 20}px`;
        summary1.style.top = `${peer1Rect.top + scrollTop + (peer1Rect.height - summary1.offsetHeight) / 2}px`;
        
        // Position summary2 to the left of peer2
        summary2.style.left = `${peer2Rect.left - summary2.offsetWidth - 20}px`;
        summary2.style.top = `${peer2Rect.top + scrollTop + (peer2Rect.height - summary2.offsetHeight) / 2}px`;
        
        // Log initial positions and dimensions
        console.log('Peer1 rect:', {
            left: peer1Rect.left,
            right: peer1Rect.right,
            width: peer1Rect.width
        });
        console.log('Peer2 rect:', {
            left: peer2Rect.left,
            right: peer2Rect.right,
            width: peer2Rect.width
        });
        console.log('Summary2 width:', summary2.offsetWidth);
        
        // Calculate the total available space between peers
        const totalSpace = peer2Rect.left - peer1Rect.right;
        
        // Fixed spacing from peers
        const PEER_SPACING = 20;
        
        // Calculate the remaining space between summaries after accounting for peer spacing
        const remainingSpace = totalSpace - (2 * PEER_SPACING) - summary1.offsetWidth - summary2.offsetWidth;
        
        // Position summary1 exactly 20px from peer1
        const summary1Left = peer1Rect.right + PEER_SPACING;
        summary1.style.left = `${summary1Left}px`;
        summary1.style.top = `${peer1Rect.top + scrollTop + (peer1Rect.height - summary1.offsetHeight) / 2}px`;
        
        // Position summary2 exactly 20px from peer2
        const summary2Left = peer2Rect.left - summary2.offsetWidth - PEER_SPACING;
        summary2.style.left = `${summary2Left}px`;
        summary2.style.top = `${peer2Rect.top + scrollTop + (peer2Rect.height - summary2.offsetHeight) / 2}px`;
        
        // Log positions for debugging
        console.log('Spacing calculation:', {
            totalSpace,
            peerSpacing: PEER_SPACING,
            remainingSpace,
            summary1Left,
            summary1Right: summary1Left + summary1.offsetWidth,
            summary2Left,
            gap: summary2Left - (summary1Left + summary1.offsetWidth)
        });
        
        // Force reflow
        summary1.offsetHeight;
        summary2.offsetHeight;
        
        // Restore transitions and make summaries visible
        summary1.style.transition = '';
        summary2.style.transition = '';
        summary1.classList.add('visible');
        summary2.classList.add('visible');
        
        // Clear and populate summaries with text
        ['peer1', 'peer2'].forEach((peerId, idx) => {
          const summaryList = document.querySelector(`#summary${idx + 1} .summary-list`);
          const summary = document.getElementById(`summary${idx + 1}`);
          summaryList.innerHTML = '';
            
          // Add all names at once
          peerState[peerId].icons.forEach(icon => {
            const li = document.createElement('li');
            li.textContent = icon.name;
            li.style.opacity = '0';
            li.style.backgroundColor = idx === 0 ? '#f5f9ff' : '#f0fffc';
            summaryList.appendChild(li);
          });
            
          // Get summary box width for positioning
          const summaryWidth = summary.getBoundingClientRect().width;
            
          // Position summaries above their respective peers
          if (idx === 0) {
            summary.style.left = `${peer1Center}px`; // Center above peer1
          } else {
            summary.style.left = `${peer2Center}px`; // Center above peer2
          }
            
          // Fade in all items together
          summary.style.opacity = '1';
          summaryList.querySelectorAll('li').forEach(li => {
            requestAnimationFrame(() => {
              li.style.transition = 'opacity 0.3s';
              li.style.opacity = '1';
            });
          });
        });

        // Resolve immediately without moving summaries
        setTimeout(() => {
          resolve();
        }, 500);
      });
    }

    async function exchangeSummaries() {
      return new Promise((resolve) => {
        const summary1 = document.getElementById('summary1');
        const summary2 = document.getElementById('summary2');
        
        const peer1Rect = document.getElementById('peer1').getBoundingClientRect();
        const peer2Rect = document.getElementById('peer2').getBoundingClientRect();
        
        // Calculate center points
        const peer1Center = peer1Rect.left + (peer1Rect.width / 2);
        const peer2Center = peer2Rect.left + (peer2Rect.width / 2);
        
        // Animate summaries moving to opposite peers
        summary1.style.transition = summary2.style.transition = 'all 0.5s ease-in-out';
        
        // Move summary1 to just left of peer2
        summary1.style.left = `${peer2Rect.left - summary1.offsetWidth - 20}px`;
        
        // Move summary2 to just right of peer1
        summary2.style.left = `${peer1Rect.right + 20}px`;
        
        setTimeout(resolve, 600);
      });
    }

    async function generateDeltas() {
      return new Promise((resolve) => {
        // Calculate deltas
        peerState.peer1.delta = peerState.peer1.icons.filter(icon1 => 
          !peerState.peer2.icons.some(icon2 => icon2.name === icon1.name)
        );
        peerState.peer2.delta = peerState.peer2.icons.filter(icon2 => 
          !peerState.peer1.icons.some(icon1 => icon1.name === icon2.name)
        );

        // Highlight the items that will become deltas
        document.querySelectorAll('#summary1 .summary-list li, #summary2 .summary-list li').forEach(li => {
          const iconName = li.textContent;
          if (peerState.peer1.delta.some(icon => icon.name === iconName) ||
              peerState.peer2.delta.some(icon => icon.name === iconName)) {
            li.style.backgroundColor = '#00d1b2';
            li.style.color = 'white';
            li.style.transition = 'all 0.3s ease-in-out';
          }
        });

        setTimeout(resolve, 1000);
      });
    }

    async function exchangeDeltas() {
      return new Promise((resolve) => {
        // Hide summaries from previous step
        document.getElementById('summary1').classList.remove('visible');
        document.getElementById('summary2').classList.remove('visible');

        const delta1 = document.getElementById('delta1');
        const delta2 = document.getElementById('delta2');
        const peer1Rect = document.getElementById('peer1').getBoundingClientRect();
        const peer2Rect = document.getElementById('peer2').getBoundingClientRect();
        
        // Calculate center points for positioning
        const peer1Center = peer1Rect.left + (peer1Rect.width / 2);
        const peer2Center = peer2Rect.left + (peer2Rect.width / 2);
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

        // First show the delta boxes in their initial positions
        ['peer1', 'peer2'].forEach((peerId, idx) => {
          const deltaBox = document.getElementById(`delta${idx + 1}`);
          const deltaList = deltaBox.querySelector('.summary-list');
          deltaList.innerHTML = '';
          
          if (idx === 0) {
            deltaBox.style.left = `${peer1Rect.right + 20}px`; // 20px right of peer1
            deltaBox.style.top = `${peer1Rect.top + scrollTop + peer1Rect.height/2}px`;
          } else {
            deltaBox.style.left = `${peer2Rect.left - deltaBox.offsetWidth - 20}px`; // 20px left of peer2
            deltaBox.style.top = `${peer2Rect.top + scrollTop + peer2Rect.height/2}px`;
          }
          
          peerState[peerId].delta.forEach(icon => {
            const li = document.createElement('li');
            const iconElement = document.createElement('i');
            iconElement.className = icon.class;
            iconElement.style.fontSize = '1.2rem';
            li.appendChild(iconElement);
            li.style.backgroundColor = '#f0fffc';
            deltaList.appendChild(li);
          });
          
          deltaBox.classList.add('visible');
        });

        // After a short delay, animate deltas moving to opposite peers
        setTimeout(() => {
          delta1.style.transition = delta2.style.transition = 'all 0.5s ease-in-out';
          delta1.style.left = `${peer2Rect.left - delta1.offsetWidth - 20}px`; // Move to left of peer2
          delta2.style.left = `${peer1Rect.right + 20}px`; // Move to right of peer1
          setTimeout(resolve, 600);
        }, 500);
      });
    }

    async function mergeDeltas() {
      return new Promise((resolve) => {
        const delta1 = document.getElementById('delta1');
        const delta2 = document.getElementById('delta2');

        // Add missing icons to each peer
        peerState.peer1.icons = [...new Set([...peerState.peer1.icons, ...peerState.peer2.delta])];
        peerState.peer2.icons = [...new Set([...peerState.peer2.icons, ...peerState.peer1.delta])];
        
        // Sort icons by name for consistent display
        peerState.peer1.icons.sort((a, b) => a.name.localeCompare(b.name));
        peerState.peer2.icons.sort((a, b) => a.name.localeCompare(b.name));
        
        // Update UI
        updatePeerUI('peer1');
        updatePeerUI('peer2');
        
        // Fade out deltas
        delta1.style.opacity = '0';
        delta2.style.opacity = '0';
        
        setTimeout(() => {
          delta1.classList.remove('visible');
          delta2.classList.remove('visible');
          resolve();
        }, 500);
      });
    }

    const stepDescriptions = [
      "Click 'Next' to begin the synchronization process.",
      "Each peer generates a summary of its current state.",
      "Peers exchange their summaries to identify differences.",
      "Each peer calculates what data the other peer is missing.",
      "Peers exchange their calculated deltas.",
      "Peers merge received deltas to achieve consistent state."
    ];

    function updateStepCaption() {
      const caption = document.getElementById('stepCaption');
      caption.textContent = stepDescriptions[currentStep];
    }

    async function handleNextStep() {
      if (currentStep >= stepDescriptions.length - 1) {
        document.getElementById('syncNextBtn').disabled = true;
        return;
      }
      
      if (isAnimating) {
        nextStepQueued = true;
        return;
      }
      
      AnimationCoordinator.setActive('sync');
      
      isAnimating = true;
      currentStep++;
      updateStepCaption();
      await runSyncAnimation();
      isAnimating = false;
      
      if (nextStepQueued) {
        nextStepQueued = false;
        handleNextStep();
      }
    }

    function resetAnimation() {
      currentStep = 0;
      isAnimating = false;
      nextStepQueued = false;
      updateStepCaption();
      document.getElementById('summary1').classList.remove('visible');
      document.getElementById('summary2').classList.remove('visible');
      document.getElementById('syncNextBtn').disabled = false;
      initializePeers();
    }

    // Set up event listeners
    document.getElementById('syncNextBtn').addEventListener('click', handleNextStep);
    document.getElementById('resetSyncBtn').addEventListener('click', resetAnimation);

    // Listen for pause events from other animations
    document.addEventListener('pause-other-animations', (event) => {
      if (event.detail.except !== 'sync') {
        currentStep = 0;
        updateStepCaption();
      }
    });

    // Initialize on load
    initializePeers();
  </script>
