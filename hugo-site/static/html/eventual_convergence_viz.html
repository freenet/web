<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Eventual Convergence Visualization</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css" />
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
      let globalSequenceCounter = 0;
      const colorSequenceMap = new Map();
      const animationQueue = new Map(); // Track ongoing animations per node
      let lastColorIndex = -1;
    </script>
    <style>
      .link {
        fill: none;
        stroke: #ccc;
        stroke-width: 2px;
      }
      .node {
        stroke: #000;
        stroke-width: 1.5px;
      }
      .message {
        r: 5;
      }
      svg {
        display: block;
        margin: 0 auto;
        max-width: 100%;
        height: auto;
      }
      .container {
        padding: 1rem;
        max-width: 100%;
        overflow-x: hidden;
      }
    </style>
  </head>
  <body>
    <section class="section">
      <div class="container">
        <h1 class="title">Freenet Eventual Convergence Simulation</h1>
        <p class="subtitle">
          Click on a node to initiate an update and see how changes propagate through the
          network.
        </p>
      </div>
    </section>
    <script>
      // Generate a random tree-like structure with 40 nodes
      function generateRandomTree(numNodes) {
        const nodes = Array.from({ length: numNodes }, (_, i) => ({
          id: i,
          color: "#87cefa",
          receivedColors: ["#87cefa"],
        }));
        const links = [];

        // Create a random parent-child relationship to form a tree with up to 5 children per node
        for (let i = 1; i < numNodes; i++) {
          const possibleParents = nodes.slice(0, i).filter((parent) => {
            const childrenCount = links.filter((link) => link.source.id === parent.id).length;
            return childrenCount < 5;
          });
          const parentIndex = Math.floor(Math.random() * possibleParents.length);
          links.push({ source: possibleParents[parentIndex], target: nodes[i] });
        }

        return { nodes, links };
      }

      let randomTreeData = generateRandomTree(80);

      const width = Math.min(window.innerWidth - 40, 1200);
      const height = Math.min(window.innerHeight - 200, 800);

      const root = d3
        .stratify()
        .id((d) => d.id)
        .parentId((d) => {
          const link = randomTreeData.links.find((link) => link.target.id === d.id);
          return link ? link.source.id : null;
        })(randomTreeData.nodes);

      const treeLayout = d3.tree().size([width, height - 200]);
      treeLayout(root);

      let svg = d3
        .select("body")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("transform", "translate(0, 100)");

      // Draw links
      const link = svg
        .selectAll(".link")
        .data(root.links())
        .enter()
        .append("path")
        .attr("class", "link")
        .attr(
          "d",
          d3
            .linkVertical()
            .x((d) => d.x)
            .y((d) => d.y)
        )
        .attr("stroke", "#1e90ff")
        .attr("stroke-width", 2);

      // Draw nodes as pie charts
      const node = svg
        .selectAll(".node")
        .data(root.descendants())
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", (d) => `translate(${d.x},${d.y})`)
        .attr("id", (d) => `node-${d.data.id}`);

      const arcGenerator = d3.arc().innerRadius(0).outerRadius(10);

      const messageArcGenerator = d3.arc().innerRadius(0).outerRadius(5);

      const pieGenerator = d3
        .pie()
        .value(1) // Each segment has equal weight
        .sort(null); // Do not sort, keep original order

      function drawPie(nodeGroup, colors) {
        const arcs = pieGenerator(colors);
        nodeGroup.selectAll("path").remove(); // Clear existing paths before drawing
        arcs.forEach((arc, i) => {
          nodeGroup
            .append("path")
            .attr("d", arcGenerator(arc))
            .attr("fill", colors[i])
            .attr("stroke", "#5f9ea0")
            .attr("stroke-width", 0.5);
        });
      }

      node.each(function (d) {
        const nodeGroup = d3.select(this);
        drawPie(nodeGroup, d.data.receivedColors);
      });

      node
        .on("mouseover", function (event, d) {
          // Show all colors with their sequence numbers in the tooltip
          const colorInfo = d.data.receivedColors
            .map(color => `${color} (${colorSequenceMap.get(color)})`)
            .join(", ");
          d3.select(this).append("title").text(colorInfo);
        })
        .on("click", function (event, d) {
          initiatePropagation(d);
        });

      // Function to animate a message along a link
      async function animateMessage(source, target, colors) {
        // Create a unique key for this specific animation
        const animationKey = `${source.data.id}-${target.data.id}`;
        if (animationQueue.get(animationKey)) {
          return;
        }

        // Filter out any undefined colors
        const validColors = colors.filter(color => color !== undefined);
        if (validColors.length === 0) return;

        // Mark this specific animation as in progress
        animationQueue.set(animationKey, true);

        try {
          // For animation, only show the colors being propagated
          const arcs = pieGenerator(validColors);
          const messageGroup = svg
            .append("g")
            .attr("class", "message")
            .attr("transform", `translate(${source.x},${source.y})`);

          arcs.forEach((arc, i) => {
            messageGroup
              .append("path")
              .attr("d", messageArcGenerator(arc))
              .attr("fill", validColors[i])
              .attr("stroke", "#4682b4")
              .attr("stroke-width", 0.5);
          });

          // Animate the message first
          await messageGroup
            .transition()
            .duration(1000)
            .attr("transform", `translate(${target.x},${target.y})`)
            .remove()
            .end();

          // Add colors to target after animation completes
          validColors.forEach(color => {
            if (!target.data.receivedColors.includes(color)) {
              target.data.receivedColors.push(color);
            }
          });
          updateNodeColors(target);
        } finally {
          // Clear animation flag when done
          animationQueue.delete(animationKey);
        }
      }

      // Helper function to blend colors
      function blendColorsList(colors) {
        // Average the RGB components to ensure order-independent blending
        let totalR = 0,
          totalG = 0,
          totalB = 0;
        colors.forEach((color) => {
          const c = d3.color(color);
          totalR += c.r;
          totalG += c.g;
          totalB += c.b;
        });

        const n = colors.length;
        return d3
          .rgb(Math.round(totalR / n), Math.round(totalG / n), Math.round(totalB / n))
          .toString();
      }

      // Function to initiate color propagation from a clicked node
      async function initiatePropagation(startNode) {
        // Clean up any undefined colors first
        startNode.data.receivedColors = startNode.data.receivedColors.filter(color => color !== undefined);
        
        // Rotate through colors sequentially
        lastColorIndex = (lastColorIndex + 1) % 3;
        const distinctColors = ["#4a90e2", "#ff7f50", "#32cd32"];
        const newColor = distinctColors[lastColorIndex];
        globalSequenceCounter += 1;
        colorSequenceMap.set(newColor, globalSequenceCounter);

        // Add the new color to the clicked node's full history
        startNode.data.receivedColors.push(newColor);
        
        // Update the clicked node's colors and start propagation
        updateNodeColors(startNode);
        await checkAndPropagate(startNode);
      }

      // Function to update node colors visually
      function updateNodeColors(node) {
        const nodeGroup = d3.select(`#node-${node.data.id}`);
        // Sort colors by sequence number and take most recent 3
        const recentColors = [...node.data.receivedColors].sort((a, b) => 
          colorSequenceMap.get(b) - colorSequenceMap.get(a)
        ).slice(0, 3);
        drawPie(nodeGroup, recentColors);
      }

      // Function to get all connected node pairs in the network
      function getAllConnectedPairs() {
        const pairs = [];
        root.descendants().forEach(node => {
          if (node.parent) {
            pairs.push([node, node.parent]);
          }
          if (node.children) {
            node.children.forEach(child => {
              pairs.push([node, child]);
            });
          }
        });
        return pairs;
      }

      // Function to check neighbors and propagate colors if needed
      async function checkAndPropagate(startNode) {
        let iteration = 0;
        const MAX_ITERATIONS = 100; // Safety limit
        
        while (iteration < MAX_ITERATIONS) {
          let hasUpdates = false;
          const nodePairs = getAllConnectedPairs();
          const propagations = [];
          
          for (const [nodeA, nodeB] of nodePairs) {
            // Clean up undefined colors
            nodeA.data.receivedColors = nodeA.data.receivedColors.filter(color => color !== undefined);
            nodeB.data.receivedColors = nodeB.data.receivedColors.filter(color => color !== undefined);
            
            // Check colors A -> B
            const colorsAtoB = nodeA.data.receivedColors.filter(
              color => !nodeB.data.receivedColors.includes(color)
            );
            
            // Check colors B -> A
            const colorsBtoA = nodeB.data.receivedColors.filter(
              color => !nodeA.data.receivedColors.includes(color)
            );
            
            if (colorsAtoB.length > 0) {
              hasUpdates = true;
              propagations.push(animateMessage(nodeA, nodeB, colorsAtoB));
            }
            
            if (colorsBtoA.length > 0) {
              hasUpdates = true;
              propagations.push(animateMessage(nodeB, nodeA, colorsBtoA));
            }
          }
          
          // If no updates were needed, we're done
          if (!hasUpdates) {
            break;
          }
          
          // Wait for all propagations in this timestep to complete
          if (propagations.length > 0) {
            await Promise.all(propagations);
            // Add a small delay between iterations to prevent UI freezing
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          
          iteration++;
        }
      }
    </script>
    </script>
  </body>
</html>
