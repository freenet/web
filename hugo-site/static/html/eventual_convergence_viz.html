<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Eventual Convergence Visualization</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css" />
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
      // Palette of 12 visually distinct colors that work well together
      const COLOR_PALETTE = [
        "#FF6B6B", // Coral Red
        "#4ECDC4", // Turquoise
        "#45B7D1", // Sky Blue
        "#96CEB4", // Sage Green
        "#FFEEAD", // Soft Yellow
        "#9B59B6", // Purple
        "#3498DB", // Blue
        "#E67E22", // Orange
        "#2ECC71", // Emerald Green
        "#F1C40F", // Yellow
        "#E74C3C", // Red
        "#1ABC9C"  // Teal
      ];
      const animationQueue = new Map(); // Track ongoing animations per node
      let lastColorIndex = 0; // Start at 0 since we're using the first color for initialization
      const globalColors = [COLOR_PALETTE[0]]; // Initialize with first color
      const MAX_COLORS = 5; // Show 5 most recent colors per node
    </script>
    <style>
      .link {
        fill: none;
        stroke: #ccc;
        stroke-width: 2px;
      }
      .node {
        stroke: #000;
        stroke-width: 1.5px;
      }
      .message {
        r: 5;
      }
      svg {
        display: block;
        margin: 0 auto;
        width: 100%;
        height: 100%;
        min-height: 600px;
        overflow: hidden;
      }
      .visualization-container {
        width: 100%;
        height: 100vh;
        min-height: 600px;
        position: relative;
      }
      @media (max-width: 768px) {
        svg {
          transform: scale(0.9);
          transform-origin: center top;
        }
      }
      .container {
        padding: 1rem;
        max-width: 100%;
        overflow-x: hidden;
      }
    </style>
  </head>
  <body>
    <section class="section py-4">
      <div class="container visualization-container" style="width: 100%; height: 100%;">
        <h1 class="title is-4">Freenet Eventual Convergence Simulation</h1>
        <p class="subtitle is-6 mb-2">
          Click nodes to initiate an update and see how changes propagate through the
          network.
        </p>
        <button class="button is-info is-small" onclick="resetVisualization()">Reset Network</button>
      </div>
    </section>
    <script>
      // Generate a random tree-like structure
      function generateRandomTree(numNodes = window.innerWidth < 768 ? 40 : 60) {
        const nodes = Array.from({ length: numNodes }, (_, i) => ({
          id: i,
          color: COLOR_PALETTE[0],
          receivedColors: [COLOR_PALETTE[0]],
        }));
        const links = [];

        // Create a random parent-child relationship to form a tree with up to 5 children per node
        for (let i = 1; i < numNodes; i++) {
          const possibleParents = nodes.slice(0, i).filter((parent) => {
            const childrenCount = links.filter((link) => link.source.id === parent.id).length;
            return childrenCount < 5;
          });
          const parentIndex = Math.floor(Math.random() * possibleParents.length);
          links.push({ source: possibleParents[parentIndex], target: nodes[i] });
        }

        return { nodes, links };
      }

      let randomTreeData = generateRandomTree(60);
      let svg;
      
      function getContainerDimensions() {
        const container = document.querySelector('.visualization-container');
        const rect = container.getBoundingClientRect();
        return {
          width: Math.max(rect.width - 40, 400),
          height: Math.max(rect.height - 40, 400)
        };
      }
      
      let { width, height } = getContainerDimensions();
      const mobileScale = width < 768 ? 0.9 : 1;

      const arcGenerator = d3.arc().innerRadius(0).outerRadius(15);
      const messageArcGenerator = d3.arc().innerRadius(0).outerRadius(7);
      const pieGenerator = d3
        .pie()
        .value(1) // Each segment has equal weight
        .sort(null); // Do not sort, keep original order

      let root = d3
        .stratify()
        .id((d) => d.id)
        .parentId((d) => {
          const link = randomTreeData.links.find((link) => link.target.id === d.id);
          return link ? link.source.id : null;
        })(randomTreeData.nodes);

      const treeLayout = d3.tree().nodeSize([60, 100]); // Use fixed node sizing instead of container-relative
      treeLayout(root);

      function handleResize() {
        ({ width, height } = getContainerDimensions());
        initializeVisualization();
      }

      // Add resize listener
      const resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(document.querySelector('.visualization-container'));

      // Initialize visualization
      function initializeVisualization() {
        // Remove existing SVG if it exists
        d3.select("svg").remove();
        
        // Create hierarchy from randomTreeData
        root = d3
          .stratify()
          .id((d) => d.id)
          .parentId((d) => {
            const link = randomTreeData.links.find((link) => link.target.id === d.id);
            return link ? link.source.id : null;
          })(randomTreeData.nodes);

        // Apply tree layout
        treeLayout(root);
        
        // Calculate bounds
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        root.each(d => {
          minX = Math.min(minX, d.x);
          maxX = Math.max(maxX, d.x);
          minY = Math.min(minY, d.y);
          maxY = Math.max(maxY, d.y);
        });
        
        // Add padding
        const padding = 40;
        const viewBoxWidth = maxX - minX + padding * 2;
        const viewBoxHeight = maxY - minY + padding * 2;
        
        svg = d3
        .select(".visualization-container")
        .append("svg")
        .attr("width", "100%")
        .attr("height", "100%")
        .attr("preserveAspectRatio", "xMidYMid meet")
        .attr("viewBox", `${minX - padding} ${minY - padding} ${viewBoxWidth} ${viewBoxHeight}`)
        .append("g");

      // Draw links
      const link = svg
        .selectAll(".link")
        .data(root.links())
        .enter()
        .append("path")
        .attr("class", "link")
        .attr(
          "d",
          d3
            .linkVertical()
            .x((d) => d.x)
            .y((d) => d.y)
        )
        .attr("stroke", "#1e90ff")
        .attr("stroke-width", 2);

      // Draw nodes as pie charts
      const node = svg
        .selectAll(".node")
        .data(root.descendants())
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", (d) => `translate(${d.x},${d.y})`)
        .attr("id", (d) => `node-${d.data.id}`);

      // Initialize node colors and event handlers
      node.each(function (d) {
        const nodeGroup = d3.select(this);
        drawPie(nodeGroup, d.data.receivedColors);
      });

      node
        .on("mouseover", function (event, d) {
          // Show all colors in the tooltip
          const colorInfo = d.data.receivedColors.join(", ");
          d3.select(this).append("title").text(colorInfo);
        })
        .on("click", function (event, d) {
          initiatePropagation(d);
        });

      }

      // Initial visualization
      initializeVisualization();

      // Function to reset the visualization
      function resetVisualization() {
        // Reset global state
        lastColorIndex = 0;
        globalColors.length = 0;
        globalColors.push(COLOR_PALETTE[0]);
        
        // Generate new tree data
        randomTreeData = generateRandomTree(80);
        
        // Create new root
        root = d3
          .stratify()
          .id((d) => d.id)
          .parentId((d) => {
            const link = randomTreeData.links.find((link) => link.target.id === d.id);
            return link ? link.source.id : null;
          })(randomTreeData.nodes);

        treeLayout(root);
        
        // Reinitialize the visualization
        initializeVisualization();
      }


      function drawPie(nodeGroup, allColors) {
        let displayColors;
        // For propagated colors, show only the most recent MAX_COLORS from global tracking
        const visibleColors = allColors.filter(color => globalColors.includes(color));
        displayColors = visibleColors.slice(-MAX_COLORS);
        // If no colors would be shown, keep the node's existing colors
        if (displayColors.length === 0) {
          displayColors = allColors;
        }
        
        const arcs = pieGenerator(displayColors);
        nodeGroup.selectAll("path").remove(); // Clear existing paths before drawing
        arcs.forEach((arc, i) => {
          nodeGroup
            .append("path")
            .attr("d", arcGenerator(arc))
            .attr("fill", displayColors[i])
            .attr("stroke", "#5f9ea0")
            .attr("stroke-width", 0.5);
        });
      }


      // Function to animate a message along a link
      async function animateMessage(source, target, colors) {
        // Create a unique key for this specific animation
        const animationKey = `${source.data.id}-${target.data.id}`;
        if (animationQueue.get(animationKey)) {
          return;
        }

        // Filter out any undefined colors
        const validColors = colors.filter(color => color !== undefined);
        if (validColors.length === 0) return;

        // Mark this specific animation as in progress
        animationQueue.set(animationKey, true);

        try {
          // For animation, only show the colors being propagated
          const arcs = pieGenerator(validColors);
          const messageGroup = svg
            .append("g")
            .attr("class", "message")
            .attr("transform", `translate(${source.x},${source.y})`);

          arcs.forEach((arc, i) => {
            messageGroup
              .append("path")
              .attr("d", messageArcGenerator(arc))
              .attr("fill", validColors[i])
              .attr("stroke", "#4682b4")
              .attr("stroke-width", 0.5);
          });

          // Animate the message first
          await messageGroup
            .transition()
            .duration(500)
            .attr("transform", `translate(${target.x},${target.y})`)
            .remove()
            .end();

          // Add colors to target after animation completes
          let colorsAdded = false;
          validColors.forEach(color => {
            if (!target.data.receivedColors.includes(color)) {
              target.data.receivedColors.push(color);
              colorsAdded = true;
            }
          });
          
          if (colorsAdded) {
            updateNodeColors(target);
          }
        } finally {
          // Clear animation flag when done
          animationQueue.delete(animationKey);
        }
      }

      // Helper function to blend colors
      function blendColorsList(colors) {
        // Average the RGB components to ensure order-independent blending
        let totalR = 0,
          totalG = 0,
          totalB = 0;
        colors.forEach((color) => {
          const c = d3.color(color);
          totalR += c.r;
          totalG += c.g;
          totalB += c.b;
        });

        const n = colors.length;
        return d3
          .rgb(Math.round(totalR / n), Math.round(totalG / n), Math.round(totalB / n))
          .toString();
      }

      // Function to initiate color propagation from a clicked node
      async function initiatePropagation(startNode) {
        // Clean up any undefined colors first
        startNode.data.receivedColors = startNode.data.receivedColors.filter(color => color !== undefined);
        
        // Rotate through the color palette sequentially
        lastColorIndex = (lastColorIndex + 1) % COLOR_PALETTE.length;
        const newColor = COLOR_PALETTE[lastColorIndex];

        // Add new color to global tracking and keep only most recent MAX_COLORS
        globalColors.push(newColor);
        if (globalColors.length > MAX_COLORS) {
            globalColors.shift(); // Remove oldest color from tracking, but don't force-remove from nodes
        }
        
        // Add the new color to the clicked node
        startNode.data.receivedColors.push(newColor);
        
        // Update the clicked node's colors and start propagation
        updateNodeColors(startNode);
        await checkAndPropagate(startNode);
      }

      // Function to update node colors visually
      function updateNodeColors(node) {
        const nodeGroup = d3.select(`#node-${node.data.id}`);
        drawPie(nodeGroup, node.data.receivedColors);
      }

      // Function to get all connected node pairs in the network
      function getAllConnectedPairs() {
        const pairs = [];
        root.descendants().forEach(node => {
          if (node.parent) {
            pairs.push([node, node.parent]);
          }
          if (node.children) {
            node.children.forEach(child => {
              pairs.push([node, child]);
            });
          }
        });
        return pairs;
      }

      // Function to check neighbors and propagate colors if needed
      async function checkAndPropagate(startNode) {
        let iteration = 0;
        const MAX_ITERATIONS = 100; // Safety limit
        
        while (iteration < MAX_ITERATIONS) {
          let hasUpdates = false;
          const nodePairs = getAllConnectedPairs();
          
          // Group pairs by source node for parallel processing
          const pairsBySource = new Map();
          nodePairs.forEach(([nodeA, nodeB]) => {
            if (!pairsBySource.has(nodeA)) pairsBySource.set(nodeA, []);
            if (!pairsBySource.has(nodeB)) pairsBySource.set(nodeB, []);
            pairsBySource.get(nodeA).push(nodeB);
            pairsBySource.get(nodeB).push(nodeA);
          });
          
          // Process all outbound connections from each node in parallel
          const propagationPromises = [];
          
          for (const [sourceNode, targetNodes] of pairsBySource) {
            // Clean up undefined colors
            sourceNode.data.receivedColors = sourceNode.data.receivedColors.filter(color => color !== undefined);
            
            for (const targetNode of targetNodes) {
              targetNode.data.receivedColors = targetNode.data.receivedColors.filter(color => color !== undefined);
              
              const colorsToPropagate = sourceNode.data.receivedColors.filter(
                color => !targetNode.data.receivedColors.includes(color)
              );
              
              if (colorsToPropagate.length > 0) {
                hasUpdates = true;
                propagationPromises.push(animateMessage(sourceNode, targetNode, colorsToPropagate));
              }
            }
          }
          
          // Wait for all parallel propagations to complete
          if (propagationPromises.length > 0) {
            await Promise.all(propagationPromises);
          }
          
          // If no updates were needed, we're done
          if (!hasUpdates) {
            break;
          }
          
          // Add a small delay between iterations
          await new Promise(resolve => setTimeout(resolve, 25));
          
          iteration++;
        }
      }
    </script>
    </script>
  </body>
</html>
